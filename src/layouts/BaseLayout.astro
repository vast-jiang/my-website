---
import "../styles/global.css";
import CommandCenter from "../components/system/CommandCenter.astro";
import BaseHead from "../components/common/BaseHead.astro";
import BootSequence from "../components/system/BootSequence.astro";
// üëá Áé∞Âú®Ëøô‰∏™Êñá‰ª∂Â≠òÂú®‰∫ÜÔºå‰∏ç‰ºöÊä•Èîô‰∫Ü
import MatrixRain from "../components/system/MatrixRain.astro";
import { ViewTransitions } from "astro:transitions";
import { SITE_CONFIG, FEATURES } from "../config/site-config";

const { title = SITE_CONFIG.title, description = SITE_CONFIG.description } =
  Astro.props;
---

<!doctype html>
<html lang="zh-cn">
  <head>
    <BaseHead title={title} description={description} />
    <script
      async
      src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <ViewTransitions />
  </head>
  <body class="crt bg-dos-bg overflow-x-hidden cursor-crosshair">
    <BootSequence />
    <MatrixRain />

    <div
      id="app-container"
      class="crt-screen min-h-screen flex flex-col p-2 md:p-8 max-w-7xl mx-auto selection:bg-dos-primary selection:text-black pb-24 md:pb-0"
    >
      <div transition:animate="fade">
        <slot />
      </div>

      <div transition:persist>
        <CommandCenter />
      </div>
    </div>

    <!-- Èº†Ê†áÊãñÂ∞æËÑöÊú¨ -->
    <script>
      interface Point {
        x: number;
        y: number;
        node: HTMLDivElement;
        offsetX: number;
        offsetY: number;
      }
      const TRAIL_LENGTH = 12;
      const LAG_FACTOR = 0.3;
      const dots: Point[] = [];
      let isMoving = false;
      let hideTimer: any;
      for (let i = 0; i < TRAIL_LENGTH; i++) {
        const node = document.createElement("div");
        const size = 8 - i * 0.5;
        const radius = size / 2;
        node.className =
          "fixed top-0 left-0 rounded-full pointer-events-none z-[9999] mix-blend-screen";
        node.style.width = `${size}px`;
        node.style.height = `${size}px`;
        node.style.backgroundColor = `rgba(51, 255, 0, ${1 - i / TRAIL_LENGTH})`;
        if (i === 0)
          node.style.boxShadow = "0 0 10px 2px rgba(51, 255, 0, 0.9)";
        node.style.opacity = "0";
        node.style.willChange = "transform, opacity";
        node.style.transition = "opacity 0.2s ease-out";
        document.body.appendChild(node);
        dots.push({ x: 0, y: 0, node, offsetX: radius, offsetY: radius });
      }
      const onMove = (x: number, y: number) => {
        const head = dots[0];
        head.x = x;
        head.y = y;
        head.node.style.transform = `translate3d(${x - head.offsetX}px, ${y - head.offsetY}px, 0)`;
        head.node.style.opacity = "1";
        if (!isMoving) {
          isMoving = true;
          loop();
        }
        dots.forEach((dot) => (dot.node.style.opacity = "1"));
        clearTimeout(hideTimer);
        hideTimer = setTimeout(() => {
          isMoving = false;
          dots.forEach((dot) => (dot.node.style.opacity = "0"));
        }, 1000);
      };
      document.addEventListener("mousemove", (e) =>
        onMove(e.clientX, e.clientY)
      );
      document.addEventListener(
        "touchmove",
        (e) => {
          const t = e.touches[0];
          onMove(t.clientX, t.clientY);
        },
        { passive: true }
      );
      function loop() {
        if (!isMoving) return;
        for (let i = 1; i < dots.length; i++) {
          const curr = dots[i];
          const prev = dots[i - 1];
          const dx = prev.x - curr.x;
          const dy = prev.y - curr.y;
          curr.x += dx * LAG_FACTOR;
          curr.y += dy * LAG_FACTOR;
          curr.node.style.transform = `translate3d(${curr.x - curr.offsetX}px, ${curr.y - curr.offsetY}px, 0)`;
        }
        requestAnimationFrame(loop);
      }
    </script>

    <!-- DRM ‰øùÊä§ËÑöÊú¨ -->
    <script is:inline>
      (function () {
        const _0x1 = atob("dmFzdC1qaWFuZw==");
        const _0x2 = atob("YXN0cm8tZG9zLXRoZW1l");
        const _0x3 = "author-credit";
        function _integrityCheck() {
          const el = document.getElementById(_0x3);
          let valid = false;
          if (el) {
            const href = el.getAttribute("href") || "";
            const style = window.getComputedStyle(el);
            const isVisible =
              style.display !== "none" &&
              style.visibility !== "hidden" &&
              style.opacity !== "0";
            if ((href.includes(_0x1) || href.includes(_0x2)) && isVisible) {
              valid = true;
            }
          }
          if (!valid) {
            document.body.innerHTML = "";
            document.body.style.backgroundColor = "black";
            document.body.style.display = "flex";
            document.body.style.justifyContent = "center";
            document.body.style.alignItems = "center";
            document.body.style.height = "100vh";
            document.body.style.color = "#ff3300";
            document.body.style.fontFamily = "monospace";
            document.body.style.textAlign = "center";
            const warning = document.createElement("div");
            warning.innerHTML = `<h1 style="font-size:4rem;margin-bottom:20px;text-shadow:0 0 10px red">‚ö†Ô∏è SYSTEM HALTED ‚ö†Ô∏è</h1><p style="font-size:1.5rem">KERNEL INTEGRITY VIOLATION DETECTED.</p><p style="margin:20px 0;color:#33ff00">The copyright information (Theme by VAST_JIANG) is missing or tampered with.</p><p style="opacity:0.7">This violates the GPL v3 License Agreement.</p>`;
            document.body.appendChild(warning);
            throw new Error("Copyright protection triggered.");
          }
        }
        window.addEventListener("load", () => {
          setTimeout(_integrityCheck, 1500);
          setInterval(_integrityCheck, 5000);
        });
      })();
    </script>

    <!-- ÁâπÊÄßÂºÄÂÖ≥ÈÄªËæë (‰ª£Á†ÅÂ§çÂà∂ & ÊïÖÈöúÊñáÂ≠ó) -->
    <script define:vars={{ features: FEATURES }}>
      document.addEventListener("astro:page-load", () => {
        // 1. ‰ª£Á†ÅÂ§çÂà∂
        if (features.codeCopy) {
          const codeBlocks = document.querySelectorAll("pre");
          codeBlocks.forEach((block) => {
            if (block.parentElement?.classList.contains("code-wrapper")) return;
            const wrapper = document.createElement("div");
            wrapper.className = "relative group code-wrapper";
            block.parentNode.insertBefore(wrapper, block);
            wrapper.appendChild(block);
            const button = document.createElement("button");
            button.className =
              "absolute top-2 right-2 text-[10px] border border-dos-dim bg-black/80 text-dos-dim px-2 py-1 opacity-0 group-hover:opacity-100 transition hover:text-dos-primary hover:border-dos-primary cursor-pointer font-mono z-10";
            button.innerText = "COPY";
            button.addEventListener("click", async () => {
              const code = block.querySelector("code")?.innerText || "";
              try {
                await navigator.clipboard.writeText(code);
                button.innerText = "COPIED!";
                button.style.borderColor = "#33ff00";
                button.style.color = "#33ff00";
                setTimeout(() => {
                  button.innerText = "COPY";
                  button.style.borderColor = "";
                  button.style.color = "";
                }, 2000);
              } catch (err) {
                button.innerText = "ERROR";
              }
            });
            wrapper.appendChild(button);
          });
        }

        // 2. ÂÖ®Â±ÄÊïÖÈöúÊñáÂ≠ó
        const letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789@#$%^&*[]<>";
        const targets = document.querySelectorAll(".glitch-effect");
        targets.forEach((target) => {
          if (!target.dataset.value) target.dataset.value = target.innerText;
          target.onmouseover = (event) => {
            let iteration = 0;
            const originalText = event.target.dataset.value;
            if (event.target.dataset.interval)
              clearInterval(parseInt(event.target.dataset.interval));
            const interval = setInterval(() => {
              event.target.innerText = event.target.innerText
                .split("")
                .map((letter, index) => {
                  if (index < iteration) return originalText[index];
                  return letters[Math.floor(Math.random() * letters.length)];
                })
                .join("");
              if (iteration >= originalText.length) clearInterval(interval);
              iteration += 1 / 2;
            }, 30);
            event.target.dataset.interval = interval.toString();
          };
        });
      });
    </script>
  </body>
</html>
